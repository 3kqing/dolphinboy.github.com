---
layout: post
title: 数据库主键设计
description: 对于数据库设计来说主键的定义是至关重要的，如何很好的设计主键是重中之重。
category: blog
tags: log
keywords: 数据库主键设计,PRIMARY KEY,数据库
---

##开篇
在我们的数据库设计中，不可逃避的就是数据库表的主键，最近要做一个通讯录系统，在设计主键的时候想到了这个问题，然后就查询了资料，再加上自己的理解写了这篇文章。当然了主键的设计对整个数据库的设计影响很大，这也是引起我重视的原因。

##定义
表通常具有包含唯一标识表中每一行的值的一列或一组列。这样的一列或多列称为表的主键 (PK)，用于强制表的实体完整性。在创建或修改表时，您可以通过定义 PRIMARY KEY约束来创建主键。

##规范
###单一主键
一个表只能有一个 PRIMARY KEY 约束，并且 PRIMARY KEY 约束中的列不能接受空值。由于 PRIMARY KEY 约束可保证数据的唯一性，因此经常对标识列定义这种约束。
如果为表指定了 PRIMARY KEY 约束，则数据库引擎将通过为主键列创建唯一索引来强制数据的唯一性。当在查询中使用主键时，此索引还可用来对数据进行快速访问。因此，所选的主键必须遵守[创建唯一索引](http://msdn.microsoft.com/zh-cn/library/ms175132(v=sql.105).aspx)的规则。

###联合主键
如果对多列定义了 PRIMARY KEY 约束，则一列中的值可能会重复，但来自 PRIMARY KEY 约束定义中所有列的任何值组合必须唯一。
如下图所示，Purchasing.ProductVendor 表中的 ProductID 和 VendorID 列构成了针对此表的复合 PRIMARY KEY 约束。这确保了 ProductID 和 VendorID 的组合是唯一的。  
![联合主键](http://aaa)  
当进行联接时，PRIMARY KEY 约束将一个表与另一个表关联。例如，若要确定哪些供应商供应哪些产品，可以在 Purchasing.Vendor 表、Production.Product 表和 Purchasing.ProductVendor 表之间使用一个三向联接。因为 ProductVendor 包含 ProductID 和 VendorID 列，所以可通过与 ProductVendor 的联系来访问 Product 表和 Vendor 表。

##主键的特性
###主键的必要性
每个表都应该具有主键，不管是单主键还是双主键，主键的存在就代表着表结构的完整性，表的记录必须得有唯一区分的字段，主键主要是用于其他表的外键关联，本记录的修改与删除，当我们没有主键时，这些操作会变的非常麻烦。

###主键的无意义性
主键的无意义性是指主键跟任何业务逻辑无关，它只表示数据的唯一性，不代表业务上的唯一性。比如订单表吧，会有“订单编号”字段，而这个字段呢在业务实际中本身就是应该具有唯一性，具有唯一标识记录的功能，但我是不推荐采用订单编号字段作为主键的，因为具有实际意义的字段，具有“意义更改”的可能性，比如订单编号在刚开始的时候我们一切顺利，后来客户说“订单可以作废，并重新生成订单，而且订单号要保持原订单号一致”，这样原来的主键就面临危险了。因此，尽量不要吧有唯一性的实际字段作为主键。所以数据库中永远都有一个主键id_，此主键本身在业务逻辑上不体现，不具有实际意义。但是这种主键在一定程序增加了复杂度，所以要视实际系统的规模大小而定，对于小项目，以后扩展不会很大的话，也允许用实际唯一的字段作主键的。

##主键的选择
###编号作主键
此方法就是采用实际业务中的唯一字段的“编号”作为主键设计，这在小型的项目中是推荐这样做的，因为这可以使项目比较简单化，但在使用中却可能带来一些麻烦，比如要进行“编号修改”时，可能要涉及到很多相关联的其他表;还有就是上面提到的“业务要求允许编号重复时”，我们再那么先知，都无法知道业务将会修改成什么。

###自动编号主键
这种方法也是很多人在使用的，就是新建一个ID字段，自动增长，非常方便也满足主键的原则。 
 
- 优点是：  
数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利;数字型的，占用空间小，易排序，在程序中传递也方便;如果通过非系统增加记录（比如手动录入，或是用其他工具直接在表里插入新记录，或老系统数据导入）时，非常方便，不用担心主键重复问题。  

- 缺点：  
其实缺点也就是来自其优点，就是因为自动增长，在手动要插入指定ID的记录时会显得麻烦，尤其是当系统与其他系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突（前提是老系统也是数字型的）;如果其他系统主键不是数字型那就麻烦更大了，会导致修改主键数据类型了，这也会导致其他相关表的修改，后果同样很严重;就算其他系统也是数字型的，在导入时，为了区分新老数据，可能想在老数据主键前统一加一个“o”(old)来表示这是老数据，那么自动增长的数字型又面临一个挑战。

###Max加一
由于自动编号存在那些问题，所以有些朋友就采用自己生成，同样是数字型的，只是把自动增长去掉了，采用在Insert时，读取Max值后加一，这种方法可以避免自动编号的问题，但也存在一个效率问题，如果记录非常大的话，那么Max()也会影响效率的;更严重的是并发性问题，如果同时有两人读到相同的Max后，加一后插入的ID值会重复，这已经是有经验教训的了。

###自制加一
考虑Max加一的效率后，有人采用自制加一，也就是建一个特别的表，字段为：表名，当前序列值。这样在往表中插入值时，先从此表中找到相应表的最大值后加一，进行插入，有人可能发现，也可能会存在并发处理，这个并发处理，我们可以采用lock线程的方式来避免，在生成此值的时，先Lock，取到值以后，再unLock出来，这样不会有两人同时生成了。这比Max加一的速度要快多了。但同样存在一个问题：在与其他系统集成时，脱离了系统中的生成方法后，很麻烦保证自制表中的最大值与导入后的保持一致，而且数字型都存在上面讲到的“o”老数据的导入问题。因此在“自制加一”中可以把主键设为字符型的。字符型的自制加一我倒是蛮推荐的，应该字符型主键可以应付很多我们意想不到的情况。

###GUID主键
目前一个比较好的主键是采用GUID，当然我是推荐主键还是字符型的，但值由GUID生成，GUID是可以自动生成，也可以程序生成，而且键值不可能重复，可以解决系统集成问题，几个系统的GUID值导到一起时，也不会发生重复，就算有“o”老数据也可以区分，而且效率很高，在.NET里可以直接使用UUID.randomUUID()进行生成，在SQL里也可以使用 NewID()生成，或者Hibernate也有生成GUID的功能。

- 优点是：  
1.同 IDENTITY 列相比，uniqueidentifier 列可以通过 NewID() 函数提前得知新增加的行 ID，为应用程序的后续处理提供了很大方便。  
2.便于数据库移植，其它数据库中并不一定具有 IDENTITY 列，而 Guid 列可以作为字符型列转换到其它数据库中，同时将应用程序中产生的 GUID 值存入数据库，它不会对原有数据带来影响。  
4.便于数据库初始化，如果应用程序要加载一些初始数据， IDENTITY 列的处理方式就比较麻烦，而 uniqueidentifier 列则无需任何处理，直接用 T-SQL 加载即可。  
5.便于对某些对象或常量进行永久标识，如类的 ClassID，对象的实例标识，UDDI 中的联系人、服务接口、tModel标识定义等。

- 缺点是：
GUID 的值有 16 个字节，与其它那些诸如 4 字节的整数相比要相对大一些。这意味着如果在数据库中使用 uniqueidentifier 键，可能会带来两方面的消极影响：存储空间增大；索引时间较慢。

##建立主键的原则
###主键无意义
如果用户看到了一个表示多对多关系的连接表中的数据，并抱怨它没有什么用处，那就证明它的主键设计地很好。

###MySQL主键应该是单列的
单列主键能够提高连接和筛选操作的效率。
>注：使用复合键的人通常有两个理由为自己开脱，而这两个理由都是错误的。其一是主键应当具有实际意义，然而，让主键具有意义只不过是给人为地破坏数据库提 供了方便。其二是利用这种方法可以在描述多对多关系的连接表中使用两个外部键来作为主键，我也反对这种做法，理由是：复合主键常常导致不良的外键，即当连 接表成为另一个从表的主表，而依据上面的第二种方法成为这个表主键的一部分，然，这个表又有可能再成为其它从表的主表，其主键又有可能成了其它从表主键的 一部分，如此传递下去，越靠后的从表，其主键将会包含越多的列了。

###永远也不要更新主键。
实际上，因为主键除了惟一地标识一行之外，再没有其他的用途了，所以也就没有理由去对它更新。如果主键需要更新，则说明主键应对用户无意义的原则被违反了。
>注：这项原则对于那些经常需要在数据转换或多数据库合并时进行数据整理的数据并不适用。

###主键不应包含动态变化的数据
如时间戳、创建时间列、修改时间列等。

###主键应当自动生成
如果由人来对主键的创建进行干预，就会使它带有除了惟一标识一行以外的意义。一旦越过这个界限，就可能产生认为修改主键的动机，这样，这种系统用来链接记录行、管理记录行的关键手段就会落入不了解数据库设计的人的手中。

##结语
主键无意义是应该坚持的，至于选择自增作为主键还是GUID作为主键，那就要根据实际情况了，例如，如果有跨库的操作，那最好还是用GUID吧。


###参考
[数据库主键设计之思考](http://www.cnblogs.com/tintown/archive/2005/03/02/111459.html '数据库主键设计之思考')  
[MySQL主键的设计原则](http://database.51cto.com/art/201010/229322.htm 'MySQL主键的设计原则')   
[PRIMARY KEY 约束](http://msdn.microsoft.com/zh-cn/library/ms191236(v=sql.105).aspx 'PRIMARY KEY约束')